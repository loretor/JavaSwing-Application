/*
* This code has been generated by the Rebel: a code generator for modern Java.
*
* Drop us a line or two at feedback@archetypesoftware.com: we would love to hear from you!
*/
package piattaforma;

import java.util.*;
import java.time.*;



// ----------- << imports@AAAAAAF+i5Bd8z8/cWo= >>
// ----------- >>

// ----------- << class.annotations@AAAAAAF+i5Bd8z8/cWo= >>
// ----------- >>
public class RegistroStrutture {
	
	//implementazione del design pattern SINGLETON
	protected static RegistroStrutture registro;//l'unica istanza della classe
	
	
    // ----------- << attribute.annotations@AAAAAAF/Ih9yqcv7c7Q= >>
    // ----------- >>
    private static Set<Struttura> ListaStrutture;
    
    
    /*
     * costruttore di RegistroStrutture reso protected perchè può essere istanziato solo con il metodo getIstance per Pattern Singleton
     */
    private RegistroStrutture() {
    	ListaStrutture = new HashSet<>();
    }

    
    /*
     * metodo per creare un nuovo registro solo qualora non ci sia già un'altra istanza di RegistroStrutture
     */
    public static RegistroStrutture getInstance() {
		if (registro == null) {
			registro = new RegistroStrutture();
		}
		return registro;	
	}
    
    
    
    public Set<Struttura> getListaStrutture() {
        return ListaStrutture;
    }

    /*
     * per aggiungere una nuova struttura alla lista
     */
    public void linkListaStrutture(Struttura Strutture) {
        if (Strutture != null) {
            getListaStrutture().add(Strutture);
        }
    }

    /*
     * per rimuovere una struttura dalla lista
     */
    public void unlinkListaStrutture(Struttura _ListaStrutture) {
        if (_ListaStrutture != null) {
            getListaStrutture().remove(_ListaStrutture);
        }
    }


    // ----------- << method.annotations@AAAAAAF/Ae3NRlS2ang= >>
    /**
     * metodo per verificare se esiste una struttura che possiede una password come quella indicata
     * @param password da controllare se esiste tra gli id delle stutture
     * @return la struttura qualora il confronto sia positivo, nulla qualora invece non ci sia un confronto positivo
     * @throws Exception 
     */
    // ----------- >>
    protected Struttura check(String password) throws Exception {
    // ----------- << method.body@AAAAAAF/Ae3NRlS2ang= >>
    	for(Struttura s: ListaStrutture) {
    		if(s.getIDstruttura().compareTo(password) == 0) {
    			return s;
    		}
    	}
    	
    	throw new Exception("password non esistente");
    // ----------- >>
    }
    
    
    
    /**
     * Metodo che serve per ritornare un campo appartenente alla struttura indicata e che possa ospitare lo sport indicato all'ora stabilita.
     * @param sport indica la tipologia del campo da prenotare
     * @param d indica l'orario e la data di prenotazione
     * @param struttura indica la struttura presso la quale si vorrebbe prenotare
     * @return si ritorna il campo solo se non è occupato nella data indicata, si ritorna null qualora sia occupato
     * @throws Exception 
     */
    protected Campo controlloDisponibilitaCampo(String sport, LocalDateTime d, Struttura struttura) throws Exception {  	
    	for(Struttura s: ListaStrutture) {
    		if(s.equals(struttura)) {  			
    			for(Campo c: s.getListaCampi()) {
    				if(c.getSport().compareTo(sport) == 0) {
    					
    					boolean occupato = false; //variabile per verificare se esiste già una prenotazione nel campo c nell'ora indicata da dataora
    					
    					for(Prenotazione p: c.getListaPrenotazioni()) {
    						if(p.getDataOra().compareTo(d)== 0) {
    							occupato = true;
    							break;
    						}
    					}
    					
    					if(!occupato) {
    						return c;
    					}
    				}
    			}
    			//eccezione
    	    	throw new Exception("non esistono campi liberi con questi criteri di ricerca");
    		}
    	}
    	
    	return null;
    	
    }
    
    
    /**
     * Metodo che serve per ritornare uno spogliatoio appartenente alla struttura indicata e prenotabile all'ora stabilita.
     * @param dataora indica l'orario e la data di prenotazione
     * @param struttura indica la struttura presso la quale si vorrebbe prenotare
     * @return si ritorna lo spogliatoio solo se non è occupato nella data indicata, si ritorna null qualora sia occupato
     * @throws Exception 
     */
    protected Spogliatoio controlloDisponibilitaSpogliatoio(LocalDateTime dataora, Struttura struttura) throws Exception {
    	for(Struttura s: ListaStrutture) {
    		if(s.equals(struttura)) {  			
    			for(Spogliatoio sp: s.getListaSpogliatoi()) {
    					
	    			boolean occupato = false; //variabile per verificare se esiste già una prenotazione nel campo c nell'ora indicata da dataora
	    					
	    			for(Prenotazione p: sp.getListaPrenotazioni()) {
	    				if(p.getDataOra().equals(dataora)) {
	    					occupato = true;
	    					break;
	    				}
	    			}
	    					
	    			if(!occupato) {
	    				return sp;
	    			}

    			}
    		}
    	}
    	
    	//eccezione
    	throw new Exception("non esistono spogliatoi liberi con questi criteri di ricerca");
    }
    
    
    
    /**
     * metodo per confermare una prenotazione senza lo spogliatoio verificando che chi prenota non sia stato bannato dalla struttura
     * @param dataora indica la data e l'ora della prenotazione
     * @param sport indica lo sport che si praticherà
     * @param cf indica il codice fiscale dell'utente che prenota
     * @param struttura indica il centro sportivo presso cui si prenota
     * @param campo indica il campo presso cui si vuole prenotare
     * @throws Exception 
     * 
     */
    protected float confermaPrenotazioneNOSpogliatoio(LocalDateTime dataora, String sport, String cf, Struttura struttura, Campo campo) throws Exception {    	
    	if(struttura.controllaBan(cf)) {
    		//eccezione
    		throw new Exception("non puoi prenotare perchè sei bannato");
    	}
    	else{
    		Prenotazione p = new Prenotazione(dataora, sport, cf, struttura, campo);
    		
    		campo.linkListaPrenotazioni(p);
    		struttura.aggiornaConteggioPrenotazioni(cf);
    		
    		return p.getPrezzo();
    	}
    	  	
    }
    

    
    /**
     * metodo per confermare una prenotazione con lo spogliatoio verificando che chi prenota non sia stato bannato dalla struttura
     * @param dataora indica la data e l'ora della prenotazione
     * @param sport indica lo sport che si praticherà
     * @param cf indica il codice fiscale dell'utente che prenota
     * @param struttura indica il centro sportivo presso cui si prenota
     * @param campo indica il campo presso cui si vuole prenotare
     * @param spogliatoio indica lo spogliatoio presso cui si vuole prenotare
     * @throws Exception 
     * 
     */
    protected float confermaPrenotazioneCONSpogliatoio(LocalDateTime dataora, String sport, String cf, Struttura struttura, Campo campo, Spogliatoio spogliatoio) throws Exception {    	  	
    	if(struttura.controllaBan(cf)) {
    		// eccezione
    		throw new Exception("non puoi prenotare perchè sei bannato");
    	}
    	else{
    		Prenotazione p = new Prenotazione(dataora, sport, cf, struttura, campo, spogliatoio);
    		
    		campo.linkListaPrenotazioni(p);
    		spogliatoio.linkListaPrenotazioni(p);
    		struttura.aggiornaConteggioPrenotazioni(cf);
    		
    		return p.getPrezzo();
    	}
    	  	
    }
    
// ----------- << class.extras@AAAAAAF+i5Bd8z8/cWo= >>
// ----------- >>
}